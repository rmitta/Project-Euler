###Cyclical Figurate Numbers

#See Project Euler for question 

import itertools
from typing import Generator

"""
First thoughts:
(A) All of the polygonal numbers can be calculated in two ways:
1. Formula in terms of n
2. Formula for the next number from the previous
- when calculating a huge list of these, it may be worth using the second

(B) Since we are restricted to 4 digit numbers, we can calculte the
finite size we are working with of options. 

(C) Are there any graph theoretic ideas we can use?

(D) The difficult part is parsing the 6 sets for cyclic groups. 
"""

#First we calculate the sets of 4-digit polygonal numbers 

def triangle(n):
    return n*(n+1)//2

def square(n):
    return n*n

def penta(n):
    return n*(3*n-1)//2

def hexa(n):
    return n*(2*n - 1)

def hepta(n):
    return n*(5*n - 3)//2

def octo(n):
    return n*(3*n-2)


def get4digits(func) -> Generator[int, None, None]:
    """
    Generates the 4-digit outputs of func, assuming it is an increasing function.

    Args:
    - func: A function that takes an integer input and returns a number.

    Yields:
    - 4-digit numbers generated by the given function.
    """
    n = 1
    while True:
        num = func(n)
        if 1000 <= num < 10000:
            yield num
        elif num >= 10000:
            break
        n += 1

polygonals = {func : [str(num) for num in get4digits(func)] for func in [triangle, square, penta, hexa, hepta, octo]}

"""
We find that all 4 digit polygonal number sets are between 40 and 96 
If we assume 70 is the average, then we have 70^6 possible 6 number sets to check to see if they are cyclic. 
Within each set there are 5!=120 ways of ordering them
Honestly that doesn't sound too bad. But I'm sure we will be able to figure out some ideas to help simplify the search.

The key is probably that we are really going to be checking a lot of unecessary ones if we contruct the full 
ordered set of 6 numbers and then ask the quesiton of whether it works. 
It seems possible that doing it step by step, adding an extra number and forming the ordered half-sets that work, we
might reduce the number of checks we need to do? 

Final Method:
Loop this method for all 5!=120 potential orderings of the polygons. 
Take X := all 4 digit triangular numbers 
Form XY := all ordered pairs from X with square numbers that have matching end/beginnings.
Repeat until we have XYZABC
Check which ones in XYZABC are closed cycles (i.e. the end connects back to the beginnig). 
"""

def cycle_match(first_str : str, second_str : str):
    """Checks to see if the last two digits of the first string match the first two digits of the second (either order)"""
    return first_str[-2:] == second_str[:2]
        

def extend_cycle(half_cycles, func):
    return [(*prev, next) for (prev,next) in itertools.product(half_cycles,polygonals[func]) if cycle_match(prev[-1],next)]


def main():
    orders = itertools.permutations([square, penta, hexa, hepta, octo], 5)
    for order in orders:
        half_cycles = [(num,) for num in polygonals[triangle]]
        for func in order:
            half_cycles = extend_cycle(half_cycles, func)
            
        full_cycles = [cycle for cycle in half_cycles if cycle[0][:2] == cycle[-1][-2:]]

        if full_cycles:
            print(full_cycles)
            print(sum([int(x) for x in full_cycles[0]]))

if __name__ == "__main__":
    main()